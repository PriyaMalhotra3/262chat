# Engineering Design Notebook

 - We first decided that we wanted as close feature parity as possible between the Part 1 and Part 2 servers, since the goal of the project was to design a custom wire protocol and compare-and-contrast it with gRPC.
   - Therefore, we created a `server.py` in each of the `part1` and `part2` folders.
 - Part 1 Server
   - We looked at various options like Python `asyncio` streams, and non-blocking `socket.select` I/O for this server, but ultimately settled on a classical one thread = one user = one session model using classical multithreading synchronization primitives like reentrant mutex locks. This was because our [protocol](part1/protocol.md) is stateful and it makes the most sense to maintain state through the execution from of the thread dedicated to the connection (and after the association phase is complete, the user).
   - The reason we made our [protocol](part1/protocol.md) stateful is because we were modeling it after the venerable SMTP, SASL, and classic `telnet` protocols, which have survived the test of time. Stateful, text-based protocols are a natural basis for a messaging application because human messaging is inherently stateful (conversations retain context). Therefore, we decided that the basic model would be that the user engages the server in plain-text back-and-forth with the server using a password until authenticated, and will remain authenticated for the duration of the session. The design choice kept our protocol and authentication mechanism simple and provided a focus on conversational UI. Morever, this design choice make multiple clients easy to implement, even in languages like C, since the basic commands are ASCII compatible and the protocol revolves around null-terminated strings, which are ubiquitous due to their introduction by C and other basic low-level systems. Simplicity of the protocol, even in low-level systems, is the basis of the longevity of SMTP and SASL, which is what we are going for.
   - Additonally, using null-terminated strings as the basic unit of the protocol obviates the need to do any struct packing or complicated reading, since both sides just need to read from the socket until the next null terminator is reached for all commands (implemented using `readstring` helper functions in both [`part1/client.py`](part1/client.py) and [`part1/server.py`](part1/server.py)).
 - Part 2 Server
   - We chose to use the newer gRPC Python `asyncio` support, since in this case we did not need one thread = one user = one session, as the gRPC model forces us to be stateless (an `Authentication` object) is sent with each request for this reason. An asyncio implementation allows us to support many more clients per process since request processing is interleaved and not bounded by the number of cores on the machine. (In order to utilize all cores down the line, the server can simply be replicated into multiple processes (as many processes as there are cores).)
	 - Using `asyncio` also allows us to not worry about race conditions that are hard to debug when using threading since in the `asyncio` model, each `async` function is itself atomic.
 - Unified Client interface
   - Due to our commitment to feature parity, we decided to extract the main functions we want out of a client talking to any server backend into `interface.py`. `part1/client.py` and `part2/client.py` provide concrete implementations of this one interface. Since clients do not usually need to be heavily multithreaded (at most just a presentation thread and a messaging thread), we decided to enforce `asyncio` usage in the interface so that no calls block the UI and we are able to leverage first-class python `async`/`await` support to communicate with the server. This design choice had many useful knock-on effects down the road:
	 - The GUI was significantly easier to implement and could easily switch between the different client implementations using just a GUI switch.
	 - Our GUI toolkit, `tkinter`, uses a main loop to update the UI in an async fashion just like `asyncio` uses a mainloop to process incoming events. We used the `asyncio` mainloop to drive `tkinter` in `gui.py` so that the UI and messages always stay synchronized, without even the need for blocking calls!
	 - We got separation of concerns of presentation (the GUI) and business logic (the client libraries) for free, which is good software engineering.
	 - We were able to write tests for **both** Part 1 and Part 2 at the *same time* in `test.py` by writing all tests to check pre-conditions and post-conditions are met. Since we want feature parity between the implementations, we demand that both the part1 implementation and part2 implementation pass the same tests. This does force us to not use the standard “replace-the-stub” method of unit-testing gRPC, but the payoff is well worth it because of each test we write, we are actually getting two code paths tested (one in each implementation) and double the coverage for the same work.
 - Utilities
   - Since it is useful to print out the local IP address of the current machine for the LAN-facing NIC so that the server administrator does not have to do more work to find it, both the Part 1 server and Part 2 server print out the LAN IP of the machine to the console so other users on the local network can connect to it. Because both Part 1 and Part 2 servers use this facility, it lives in `ip.py` in the project root directory, where both implementations can access it via Python’s relative imports.
